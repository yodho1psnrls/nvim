#pragma once

#include "../meta_func.hpp"

// NOTE: Each of the order/shift traits classes have one to one
// mapping to arrange_traits


struct ShiftArrange {
  
  template <typename Container>
  static void will_insert(
    Container& keys,
    typename Container::value_type at_key,
    typename Container::difference_type n = 1
  ) {
    static_assert(is_range_v<Container>);
    for(auto&& x : keys)
      x += n * (x >= at_key);
  }

  template <typename Container>
  static void was_erased(
    Container& keys,
    typename Container::value_type at_key,
    typename Container::difference_type n = 1
  ) {
    static_assert(is_range_v<Container>);
    auto first = keys.begin();
    while(first != keys.end()) {
      if (*first >= at_key && *first < at_key + n) {
        first = keys.erase(first);
        continue;
      }
      *first -= n * (*first >= at_key + n);
      ++first;
    }
  }
  
};


struct ChainArrange {

  // NOTE: You will need to know the size of the container
  // that the keys point to

  template <typename Container>
  static void will_insert(
    Container& keys,
    typename Container::value_type at_key,
    typename Container::difference_type n = 1
  ) {
    static_assert(is_range_v<Container>);
    // for(auto&& x : keys)
    //   x += (x*)
  }

  template <typename Container>
  static void was_erased(
    Container& keys,
    typename Container::value_type at_key,
    typename Container::difference_type n = 1
  ) {
    static_assert(is_range_v<Container>);
    
  }
  
};


struct NoShiftArrange {

  template <typename Container>
  static void will_insert(
    Container& keys,
    typename Container::value_type at_key,
    typename Container::difference_type n = 1
  ) {
    static_assert(is_range_v<Container>);
  }

  template <typename Container>
  static void was_erased(
    Container& keys,
    typename Container::value_type at_key,
    typename Container::difference_type n = 1
  ) {
    static_assert(is_range_v<Container>);
  }
  
};


template <typename BaseVec>
struct UnorderedVector;


template <typename VecType>
struct arrange_traits : public
  _if_t<
    is_vector_container_v<VecType>,
    ShiftArrange,
    NoShiftArrange
  > {};


template <typename BaseVec>
struct arrange_traits<
  UnorderedVector<BaseVec>
> : public ChainArrange {};




