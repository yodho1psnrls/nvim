#pragma once

#include "../iterators/filter_iterator.hpp"

#include <initializer_list>
#include <stdexcept>
#include <vector>

#include <utility>
#include <iterator>
// #include <type_traits>

// The container of bools should be of the same type

// TODO: Generalize this wrapper for more containers
// that only vector-like and add garbage policies that will
// be chosed depending on the possibilities of the key type
// For example, if it is an index, then use a bit_mast like std::vector<bool>,
// if it is comparable with std::less<>, then choose a std::set<key> or std::priority_queue
// if it is not any of the above, then choose std::queue<key> or std::stack<key>
// or std::unordered_set<key>(if hashable)

// TODO: Make it such that when the VecType's value is integer, to mark
// them as erased by setting them to -1, also filter_iterator can handle that
// You could make it as policy for different Garbage System configurations


template <typename VecType>
class GarbageVector {

  VecType _vec;
  std::vector<bool> _erased_mask;
  size_t _erased_count {};

public:

  using base_type = VecType;
  using size_type = typename base_type::size_type;
  using difference_type = typename base_type::difference_type;
  
  using value_type = typename base_type::value_type;
  using reference = typename base_type::reference;
  using const_reference = typename base_type::const_reference;
  using pointer = typename base_type::pointer;
  using const_pointer = typename base_type::const_pointer;
  
  using iterator = FilterIterator<typename VecType::iterator, std::vector<bool>::const_iterator, false>;
  using const_iterator = FilterIterator<typename VecType::const_iterator, std::vector<bool>::const_iterator, false>;

  VecType& base() { return _vec; }
  const VecType& base() const { return _vec; }

  
  // using base_type::base_type;

  GarbageVector() : _vec(), _erased_mask() {}
  
  template <typename IterType>
  GarbageVector(IterType first, IterType last)
  : _vec(first, last)
  // , _erased_mask(std::distance(first, last), false) {}
  , _erased_mask(_vec.size(), false) {}
  
  GarbageVector(std::initializer_list<value_type> l)
  : _vec(l), _erased_mask(l.size(), false) {}

  GarbageVector(size_type n, const value_type& val = value_type())
  : _vec(n, val), _erased_mask(n, false) {}

  template <typename IterType>
  void assign(IterType first, IterType last) {
    _vec.assign(first, last);
    _erased_mask.assign(_vec.size(), false);
  }
  
  void assign(std::initializer_list<value_type> l) {
    _vec.assign(l);
    _erased_mask.assign(l.size(), false);
  }

  void assign(size_type n, const value_type& val) {
    _vec.assign(n, val);
    _erased_mask.assign(n, false);
  }

protected:

  iterator _nonconst_iter(const_iterator cit) {
    return _vec.begin() + (cit - _vec.cbegin());
  }

public:

  bool is_compact() const {
    return !_erased_count;
  }

  void compact(difference_type id) {
    if (!is_erased(id))
      throw std::invalid_argument("The element which you want to compact should be marked as erased beforehand");
   
        
    // _erased_mask[i] = false; // They should be separate
    // _vec.erase(_vec.cbegin() + i);

    // _erased_count -= is_erased(id);
    --_erased_count;

    if constexpr (std::is_move_assignable_v<reference>) {
      _vec[id] = std::move(_vec.back());
      _erased_mask[id] = std::move(_erased_mask.back());
    }
    else {
      _vec[id] = _vec.back();
      _erased_mask[id] = _erased_mask.back();
    }

    _vec.pop_back();
    _erased_mask.pop_back();
  }
  
  // void compact() {
  //  if (is_compact())
  //    return;
  //
  //  for(difference_type i = _vec.size() - 1; i != -1; --i)
  //    if(is_erased(i)) {
  //      _vec.erase(_vec.cbegin() + i);
  //      // _erased_mask[i] = false; // They should be separate
  //    }
  //
  //  _erased_mask.assign(_vec.size(), false);
  //  _erased_count = 0;
  // }
  
  void compact() {
    if (is_compact())
      return;

    auto it = _vec.cend();
    --it;
    auto end = _vec.cbegin();
    --end;
    auto eit = _erased_mask.cend();
    --eit;

    while(it != end) {
      if (*eit)
        _vec.erase(it);
      --it;
      --eit;
    }

    _erased_mask.assign(_vec.size(), false);
    _erased_count = 0;
  }

  size_t erased_size() const {
    return _erased_count;
  }

  bool is_erased(size_type id) const {
    return _erased_mask[id];
  }
  
  bool is_erased(const_iterator it) const {
    return _erased_mask[it - _vec.cbegin()];
  }

  // ---------------------------------------------------------------------- //
  
  bool empty() const {
    // return _vec.empty();
    return _vec.size() == _erased_count;
  }

  size_type size() const {
    // return _vec.size();
    return _vec.size() - _erased_count;
  }
  
  /*void resize(size_type n) {
    // if (n < _erased_mask.size() && _erased_count)
    //  for(auto it = _erased_mask.begin() + n; it != _erased_mask.end(); ++it)
    if (_erased_count)
      for(auto it = _erased_mask.begin() + n; it < _erased_mask.end(); ++it)
        _erased_count -= *it;

    _vec.resize(n);
    _erased_mask.resize(n, false);
  }*/
  
  size_type capacity() const {
    return _vec.capacity();
  }

  void reserve(size_type n) {
    _vec.reserve(n);
    _erased_mask.reserve(n);
  }

  // ------------------------------------------------------------------- //
  
  difference_type idx(const_iterator it) const {
  // difference_type iter_to_id(const_iterator it) const {
    return it.base() - _vec.cbegin();
  }

  iterator find(difference_type id) {
  // iterator id_to_iter(difference_type id) {
    if (is_erased(id))
      throw std::invalid_argument("Cannot get the iterator of an erased element");
    return iterator(_vec.begin() + id, _vec.end(), _erased_mask.cbegin() + id);
  }
  
  const_iterator find(difference_type id) const {
  // const_iterator id_to_iter(difference_type id) const {
    if (is_erased(id))
      throw std::invalid_argument("Cannot get the iterator of an erased element");
    return const_iterator(_vec.cbegin() + id, _vec.cend(), _erased_mask.cbegin() + id);
  }

  // Returns a view which indicates how each index for the elements is offsetted  
  auto offsets() const {

  }
  
  // ------------------------------------------------------------------- //

  reference operator[](difference_type i) {
    if (is_erased(i))
      throw std::invalid_argument("Cannot acess erased/invalidated element");

    return _vec[i];
  }

  const_reference operator[](difference_type i) const {
    if (is_erased(i))
      throw std::invalid_argument("Cannot acess erased/invalidated element");

    return _vec[i];
  }
  
  reference at(difference_type i) {
    if (is_erased(i))
      throw std::invalid_argument("Cannot acess erased/invalidated element");

    return _vec.at(i);
  }

  const_reference at(difference_type i) const {
    if (is_erased(i))
      throw std::invalid_argument("Cannot acess erased/invalidated element");

    return _vec.at(i);
  }
  
  // ---------------------------------------------------------------------- //

  /*reference front() {
    if (empty())
      throw std::invalid_argument("Cannot get the front of an empty container");

    auto it = _vec.begin();
    auto eit = _erased_mask.cbegin();

    while(*eit) {
      ++eit;
      ++it;
    }

    return *it;
  }
  
  const_reference front() const {
    if (empty())
      throw std::invalid_argument("Cannot get the front of an empty container");

    auto it = _vec.cbegin();
    auto eit = _erased_mask.cbegin();

    while(*eit) {
      ++eit;
      ++it;
    }

    return *it;
  }
  
  reference back() {
    if (empty())
      throw std::invalid_argument("Cannot get the front of an empty container");

    auto it = std::prev(_vec.end());
    auto eit = std::prev(_erased_mask.cbegin());

    while(*eit) {
      --eit;
      --it;
    }

    return *it;
  }
  
  const_reference back() const {
    if (empty())  // if _vec.size() == _erased_count
      throw std::invalid_argument("Cannot get the front of an empty container");

    auto it = std::prev(_vec.cend());
    auto eit = std::prev(_erased_mask.cbegin());

    while(*eit) {
      --eit;
      --it;
    }

    return *it;
  }*/
  
  // ---------------------------------------------------------------------- //
  
  iterator begin() {
    return iterator(
      _vec.begin(),
      _vec.end(),
      _erased_mask.cbegin()
    );
  }
  
  iterator end() {
    return iterator(
      _vec.end(),
      _vec.end(),
      _erased_mask.cend()
    );
  }
  
  const_iterator begin() const {
    return const_iterator(
      _vec.begin(),
      _vec.end(),
      _erased_mask.cbegin()
    );
  }
  
  const_iterator end() const {
    return const_iterator(
      _vec.end(),
      _vec.end(),
      _erased_mask.cend()
    );
  }
  
  const_iterator cbegin() const {
    return const_iterator(
      _vec.cbegin(),
      _vec.cend(),
      _erased_mask.cbegin()
    );
  }
  
  const_iterator cend() const {
    return const_iterator(
      _vec.cend(),
      _vec.cend(),
      _erased_mask.cend()
    );
  }
  
  // ---------------------------------------------------------------------- //


  // template <typename ...Args>
  // iterator emplace(Args&&... args) {
    // if (is_compact()) {
    //  _vec.emplace_back(std::forward<Args>(args)...);
    //  return std::prev(end());
    // }
    // else
  // }

  iterator insert(const value_type& val) {
    if (is_compact()) {
      _vec.push_back(val);
      _erased_mask.push_back(false);
      return std::prev(_vec.end());
    }

    difference_type i = 0;
    while(!_erased_mask[i])
      ++i;

    _erased_mask[i] = false;
    --_erased_count;

    iterator it = _vec.begin() + i;
    *it = val;
    return it;
  }
  
  iterator insert(value_type&& val) {
    if (is_compact()) {
      _vec.push_back(std::move(val));
      _erased_mask.push_back(false);
      return std::prev(_vec.end());
    }
    
    --_erased_count;

    iterator it = _vec.begin();
    auto eit = _erased_mask.begin();
    while(!*eit) {
      ++eit;
      ++it;
    }
    *eit = false;

    *it = std::move(val);
    return it;
  }


  iterator erase(const_iterator where) {
    difference_type id = where.base() - _vec.cbegin();
    auto eit = _erased_mask.begin() + id;
    auto it = _vec.begin() + id;

    *eit = true;
    ++_erased_count;

    return iterator(it, _vec.end(), eit);
  }

};


