#pragma once

#include "../meta_func.hpp"

#include <type_traits>  // std::is_constructible_v
#include <utility>      // std::forward

#include <iterator>
#include <stdexcept>
#include <cassert>
#include "index_iterator.hpp"


struct static_jump_policy_tag {};
struct fixed_jump_policy_tag : public static_jump_policy_tag {};
struct nonfixed_jump_policy_tag : public fixed_jump_policy_tag {};


// TODO: Fix get_diff, because currently it works, but it casts to the most base
// jump_iterator, which means that it gets the difference with respect
// to the most Base JumpPolicy when used in iterable_iterator operator-
// which means its wrong

// NOTE: We Tag all of them, so we can use them in iterable_iterator
// multiple times as different types, so EBO kicks in, and memory is
// shrinked


template <int Index = 0>
class NoPolicy {
// template <typename Tag>
// template <int Index>
// class __NoPolicy {

  template <typename IT>
  using IC = typename std::iterator_traits<IT>::iterator_category;

public:
  
  // https://stackoverflow.com/questions/67606956/standard-or-idiomatic-empty-object-in-c
  // static inline NoPolicy EMPTY = NoPolicy();

  using difference_type = std::ptrdiff_t;
  using iterator_category = std::random_access_iterator_tag;
  using policy_category = static_jump_policy_tag;

  template <int ID>
  using indexed = NoPolicy<ID>;
  
  // template <typename IT>
  // using difference_type = typename std::iterator_traits<IT>::difference_type;
  // template <typename IT>
  // using iterator_category = typename std::iterator_traits<IT>::iterator_category;


  // static constexpr void base() {}
  // static constexpr std::ptrdiff_t base() { return 1; }
  // static constexpr NoPolicy& policy();
  static constexpr std::ptrdiff_t value() { return 1; }

  explicit NoPolicy() = default;
  // explicit __NoPolicy() = default;

  template <int ID> 
  constexpr operator NoPolicy<ID>() const {
    return NoPolicy<ID>();
  }

// protected:
public:

  // template <typename IT>
  // jump_iterator<IT, NoPolicy> get_iter(const IT& it) const {
  //   return jump_iterator<IT, NoPolicy>(it, *this);
  // }

  template <typename IT>
  static void advance(IT& it) {
    ++it;
  }
  
  template <typename IT, typename = std::enable_if_t<std::is_base_of_v<std::bidirectional_iterator_tag, IC<IT>>>>
  static void radvance(IT& it) {
    --it;
  }
 
  template <typename IT, typename = std::enable_if_t<std::is_base_of_v<std::random_access_iterator_tag, IC<IT>>>>
  static void advance(IT& it, difference_type i) {
    it += i;
  }
  
  template <typename IT, typename = std::enable_if_t<std::is_base_of_v<std::random_access_iterator_tag, IC<IT>>>>
  static void radvance(IT& it, difference_type i) {
    it -= i;
  }

  // template <typename IT>
  // difference_type get_diff(
  //   const jump_iterator<IT, NoPolicy>& lhs,
  //   const jump_iterator<IT, NoPolicy>& rhs) const {
  template <typename JIT, typename = std::enable_if_t<std::is_base_of_v<std::random_access_iterator_tag, IC<JIT>>>>
  static difference_type get_diff(const JIT& lhs, const JIT& rhs) {
    static_assert(std::is_base_of_v<std::random_access_iterator_tag, IC<JIT>>);
    return lhs.base() - rhs.base();
  }

};

// inline NoPolicy EmptyNoPolicy = NoPolicy();
// constexpr NoPolicy& NoPolicy::policy() {
//   return EmptyNoPolicy;
// }

/*struct NoPolicy {
  // template <typename Tag>
  // using tagged = __NoPolicy<Tag>;
  template <int Index>
  using indexed = __NoPolicy<Index>;
  using type = __NoPolicy<0>;
};*/


// Static version of FixedJumpPolicy
template <std::ptrdiff_t N, int Index = 0>
class StaticJumpPolicy {
// template <int Index, std::ptrdiff_t N>
// class __StaticJumpPolicy {

  template <typename IT>
  using IC = typename std::iterator_traits<IT>::iterator_category;

public:
  
  // https://stackoverflow.com/questions/67606956/standard-or-idiomatic-empty-object-in-c
  //static inline StaticJumpPolicy EMPTY = {};
  static inline StaticJumpPolicy EMPTY = StaticJumpPolicy<N>();
  // static inline __StaticJumpPolicy EMPTY = StaticJumpPolicy<N>();

  using difference_type = std::ptrdiff_t;
  using iterator_category = std::random_access_iterator_tag;
  using policy_category = static_jump_policy_tag;

  template <int ID>
  using indexed = StaticJumpPolicy<N, ID>;

  // constexpr std::ptrdiff_t base() { return N; }
  // static constexpr StaticJumpPolicy& policy() { return EMPTY; }
  //static constexpr StaticJumpPolicy policy() { return StaticJumpPolicy(); }
  //static constexpr StaticJumpPolicy policy() { return {}; }

  static constexpr std::ptrdiff_t value() { return N; }

  explicit StaticJumpPolicy() = default;
  // explicit __StaticJumpPolicy() = default;

  template <int ID> 
  constexpr operator StaticJumpPolicy<N, ID>() const {
    return StaticJumpPolicy<N, ID>();
  }

// protected:
public:

  // template <typename IT>
  // jump_iterator<IT, StaticJumpPolicy> get_iter(const IT& it) const {
  //   return jump_iterator<IT, StaticJumpPolicy>(it, *this);
  // }

  template <typename IT>
  static void advance(IT& it) {
    static_assert(std::is_base_of_v<std::random_access_iterator_tag, IC<IT>>);
    it += N;
  }
  
  template <typename IT>
  static void radvance(IT& it) {
    static_assert(std::is_base_of_v<std::random_access_iterator_tag, IC<IT>>);
    it -= N;
  }
 
  template <typename IT>
  static void advance(IT& it, difference_type i) {
    static_assert(std::is_base_of_v<std::random_access_iterator_tag, IC<IT>>);
    it += N * i;
  }
  
  template <typename IT>
  static void radvance(IT& it, difference_type i) {
    static_assert(std::is_base_of_v<std::random_access_iterator_tag, IC<IT>>);
    it -= N * i;
  }

  // template <typename IT>
  // difference_type get_diff(
  //   const jump_iterator<IT, StaticJumpPolicy>& lhs,
  //   const jump_iterator<IT, StaticJumpPolicy>& rhs) const {
  template <typename JIT>
  static difference_type get_diff(const JIT& lhs, const JIT& rhs) {
    static_assert(std::is_base_of_v<std::random_access_iterator_tag, IC<JIT>>);
		if constexpr (N)
			return (lhs.base() - rhs.base()) / N;
		return 0;
  }

};

template <int Index>
struct StaticJumpPolicy<1, Index>
// template <int Index>
// struct __StaticJumpPolicy<Index, 1>
: public NoPolicy<Index> {

  using NoPolicy<Index>::NoPolicy;
 
  StaticJumpPolicy(const NoPolicy<Index>& other)
    : StaticJumpPolicy() {}
};

/*template <std::ptrdiff_t N>
struct StaticJumpPolicy {
  template <int Index>
  using indexed = __StaticJumpPolicy<Index, N>;
  using type = __StaticJumpPolicy<0, N>;
};*/



template <typename T, int Index = 0>
class FixedJumpPolicy {
// template <int Index>
// class __FixedJumpPolicy {

  static_assert(std::is_integral_v<T>);

  template <typename IT>
  using IC = typename std::iterator_traits<IT>::iterator_category;
  
  T _n;  // stride(jump) length

public:

  //using difference_type = typename std::iterator_traits<IT>::difference_type;
  using difference_type = T;
  using iterator_category = std::random_access_iterator_tag;
  using policy_category = fixed_jump_policy_tag;

  template <int ID>
  using indexed = FixedJumpPolicy<T, ID>;
  
  //difference_type stride() const { return _n; }
  // std::ptrdiff_t base() const { return _n; }
  // const FixedJumpPolicy& policy() const { return *this; }
  difference_type value() const { return _n; }
  // FixedJumpPolicy() = default;
  FixedJumpPolicy(difference_type stride) : _n(stride) {}
  // __FixedJumpPolicy(difference_type stride) : _n(stride) {}
  
  template <typename OT>
  FixedJumpPolicy(const FixedJumpPolicy<OT, Index> other)
  : _n(other.value()) {
    static_assert(std::is_convertible_v<OT, T>);
  }

  template <int OtherID> 
  operator FixedJumpPolicy<T, OtherID>() const { return _n; }
  
  //template <typename IT>
  //FixedJumpPolicy(const jump_iterator<IT, FixedJumpPolicy>&) = delete;

// protected:
public:

  // template <typename IT>
  // jump_iterator<IT, FixedJumpPolicy> get_iter(const IT& it) const {
  //   return jump_iterator<IT, FixedJumpPolicy>(it, *this);
  // }
 
  template <typename IT>
  void advance(IT& it) const {
    static_assert(std::is_base_of_v<std::random_access_iterator_tag, IC<IT>>);
    it += _n;
  }
  
  template <typename IT>
  void radvance(IT& it) const {
    static_assert(std::is_base_of_v<std::random_access_iterator_tag, IC<IT>>);
    it -= _n;
  }
 
  template <typename IT>
  void advance(IT& it, difference_type i) const {
    static_assert(std::is_base_of_v<std::random_access_iterator_tag, IC<IT>>);
    it += _n * i;
  }
  
  template <typename IT>
  void radvance(IT& it, difference_type i) const {
    static_assert(std::is_base_of_v<std::random_access_iterator_tag, IC<IT>>);
    it -= _n * i;
  }

  // template <typename IT>
  // difference_type get_diff(
  //   const jump_iterator<IT, FixedJumpPolicy>& lhs,
  //   const jump_iterator<IT, FixedJumpPolicy>& rhs) const {
  //   static_assert(std::is_base_of_v<std::random_access_iterator_tag, IC<IT>>);
  // template <typename JIT, typename std::enable_if_t<std::is_base_of_v<typename JIT::policy_type, FixedJumpPolicy>>>
  template <typename JIT>
  // difference_type get_diff(const JIT& lhs, const JIT& rhs) const {
    // return (lhs.base() - rhs.base()) / _n;
  static difference_type get_diff(const JIT& lhs, const JIT& rhs) {
		if (lhs.value())
			return (lhs.base() - rhs.base()) / lhs.value();
		return 0;

		// NOTE: Branchless check for division by zero doesnt work, the thread still stops
		// bool COND = lhs.value() != 0;
    // return COND * (lhs.base() - rhs.base()) / lhs.value() + !COND * 0;
		// return bool(lhs.value()) * ((lhs.base() - rhs.base()) / lhs.value());
  }

};


/*struct FixedJumpPolicy {
  template <int Index>
  using indexed = __FixedJumpPolicy<Index>;
  using type = __FixedJumpPolicy<0>;
};*/


// ================================================================================= //

template <typename IndexIter, bool Cyclic = false, int Index = 0>
class JumpByIndexValue {
// template <int Index, typename IndexIter>
// class __JumpByIndexValue {
  template <typename IT>
  using IC = typename std::iterator_traits<IT>::iterator_category;
  
  static_assert(is_iterator_v<IndexIter>);
  static_assert(std::is_integral_v<typename std::iterator_traits<IndexIter>::value_type>);

  IndexIter _id_it;

public:
  
  using difference_type = typename std::iterator_traits<IndexIter>::difference_type;
  using iterator_category = base_t<IC<IndexIter>, std::bidirectional_iterator_tag>;
  using policy_category = nonfixed_jump_policy_tag;

  template <int ID>
  using indexed = JumpByIndexValue<IndexIter, Cyclic, ID>;

  // JumpByIndexValue() = default;
  JumpByIndexValue(const IndexIter& index_it) : _id_it(index_it) {}
  // __JumpByIndexValue(const IndexIter& index_it) : _id_it(index_it) {}
  
  template <typename IT>
  JumpByIndexValue(const JumpByIndexValue<IT, Cyclic, Index>& other)
  : _id_it(other.base()) {
    static_assert(std::is_convertible_v<IT, IndexIter>);
  }

  template <int ID>
  operator JumpByIndexValue<IndexIter, Cyclic, ID>() const { return _id_it; }

	using iter_type = IndexIter;
  iter_type& iter() { return _id_it; }
  const iter_type& iter() const { return _id_it; }

  // const IndexIter& base() const { return _id_it; }
  difference_type value() const { return *_id_it; }
  // const JumpByIndexValue& policy() const { return *this; }
  
  //template <typename IT>
  //JumpByIndexValue(const jump_iterator<IT, JumpByIndexValue>&) = delete;

// protected:
public:

  // template <typename IT>
  // jump_iterator<IT, JumpByIndexValue> get_iter(const IT& it) const {
  //   return jump_iterator<IT, JumpByIndexValue>(it, *this);
  // }
 
  void advance_alone() { ++_id_it; }
  void radvance_alone() { --_id_it; }
  void advance_alone(difference_type i) { _id_it += i; }
  void radvance_alone(difference_type i) { _id_it -= i; }

 //  template <typename IT>
 //  IT next(const IT&) { return *std::next(_id_it); }
 //  
 //  template <typename IT>
 //  IT prev(const IT&) { return *std::prev(_id_it); }
 //  
 //  template <typename IT>
 //  IT next(const IT&, difference_type i) { return *std::next(_id_it, i); }
 // 
 //  template <typename IT>
 //  IT prev(const IT&, difference_type i) { return *std::prev(_id_it, i); }


  template <typename IT>
  // template <typename IT, typename = std::enable_if_t<is_iterator_v<IT>>>
  void advance(IT& it) {
    static_assert(std::is_base_of_v<std::random_access_iterator_tag, IC<IT>>);
    it += *(_id_it++);
  }
  
  template <typename IT>
  void radvance(IT& it) {
    static_assert(std::is_base_of_v<std::random_access_iterator_tag, IC<IT>>);
    it -= *(--_id_it);
  }

};

/*template <typename IndexIter>
struct JumpByIndexValue {
  template <int Index>
  using indexed = __JumpByIndexValue<Index, IndexIter>;
  using type = __JumpByIndexValue<0, IndexIter>;
};*/


template <typename IndexIter, int Index = 0>
class JumpByIndexDiff {
// template <int Index, typename IndexIter>
// class __JumpByIndexDiff {

  template <typename IT>
  using IC = typename std::iterator_traits<IT>::iterator_category;
  
  static_assert(is_iterator_v<IndexIter>);
  static_assert(std::is_integral_v<typename std::iterator_traits<IndexIter>::value_type>);

  IndexIter _id_it;

public:
 
  using difference_type = typename std::iterator_traits<IndexIter>::difference_type;
  using iterator_category = typename std::iterator_traits<IndexIter>::iterator_category;
  using policy_category = nonfixed_jump_policy_tag;

  template <int ID>
  using indexed = JumpByIndexDiff<IndexIter, ID>;
  
	using iter_type = IndexIter;
  iter_type& iter() { return _id_it; }
  const iter_type& iter() const { return _id_it; }

  // const IndexIter& base() const { return _id_it; }
  // const JumpByIndexDiff& policy() const { return *this; }
  difference_type value() const { return *(std::next(_id_it)) - *_id_it; }
  // JumpByIndexDiff() = default;
  JumpByIndexDiff(const IndexIter& index_id) : _id_it(index_id) {}
  // __JumpByIndexDiff(const IndexIter& index_id) : _id_it(index_id) {}
  
  template <typename IT>
  JumpByIndexDiff(const JumpByIndexDiff<IT, Index>& other)
  : _id_it(other.base()) {
    static_assert(std::is_convertible_v<IT, IndexIter>);
  }

  template <int ID> 
  operator JumpByIndexDiff<IndexIter, ID>() const {
    return _id_it;
  }
  
  //template <typename IT>
  //JumpByIndexDiff(const jump_iterator<IT, JumpByIndexDiff>&) = delete;

// protected:
public:

  // template <typename IT>
  // jump_iterator<IT, JumpByIndexDiff> get_iter(const IT& it) const {
  //   return jump_iterator<IT, JumpByIndexDiff>(it, *this);
  // }
  
  void advance_alone() { ++_id_it; }
  void radvance_alone() { --_id_it; }
  void advance_alone(difference_type i) { _id_it += i; }
  void radvance_alone(difference_type i) { _id_it -= i; }
 
  template <typename IT>
  void advance(IT& it) {
    static_assert(std::is_base_of_v<std::random_access_iterator_tag, IC<IT>>);
    auto id0 = *_id_it;
    it += *(++_id_it) - id0;
  }

  template <typename IT>
  void radvance(IT& it) {
    static_assert(std::is_base_of_v<std::random_access_iterator_tag, IC<IT>>);
    auto id0 = *_id_it;
    it += *(--_id_it) - id0;
  }

  template <typename IT>
  void advance(IT& it, difference_type i) {
    static_assert(std::is_base_of_v<std::random_access_iterator_tag, IC<IT>>);
    auto id0 = *_id_it;
    it += *(_id_it += i) - id0;
  }

  template <typename IT>
  void radvance(IT& it, difference_type i) {
    static_assert(std::is_base_of_v<std::random_access_iterator_tag, IC<IT>>);
    auto id0 = *_id_it;
    it += *(_id_it -= i) - id0;
  }

  // template <typename IT>
  // difference_type get_diff(
  //   const jump_iterator<IT, JumpByIndexDiff>& lhs,
  //   const jump_iterator<IT, JumpByIndexDiff>& rhs) const {
  template <typename JIT>
  static difference_type get_diff(const JIT& lhs, const JIT& rhs) {
    static_assert(std::is_base_of_v<std::random_access_iterator_tag, IC<JIT>>);
    // return lhs.policy()._id_it - rhs.policy()._id_it;
    return lhs.policy().base() - rhs.policy().base();
  }

};

/*template <typename IndexIter>
struct JumpByIndexDiff {
  template <int Index>
  using indexed = __JumpByIndexDiff<Index, IndexIter>;
  using type = __JumpByIndexDiff<0, IndexIter>;
};*/


// This Policy allows you you use jump iterator with
//  non-random access iterators
// It might seem redundant at first, but this policy
//  could be used as stride policy for tensor iterator
//  or size policy for tensor iterable
// Allowing classes like std::list to be the flat base
//  for JaggedMatrix and Tensors
template <typename IterIter, int Index = 0>
class JumpByEqualNext {

  template <typename IT>
  using IC = typename std::iterator_traits<IT>::iterator_category;
  
  template <typename IT>
  using VT = typename std::iterator_traits<IT>::value_type;

  static_assert(is_iterator_v<IterIter>);
  // static_assert(is_iterator_v<typename std::iterator_traits<IterIter>::value_type>);

  IterIter _it_it;

public:
  
  using difference_type = typename std::iterator_traits<IterIter>::difference_type;
  using iterator_category = typename std::iterator_traits<IterIter>::iterator_category;
  using policy_category = nonfixed_jump_policy_tag;

  template <int ID>
  using indexed = JumpByEqualNext<IterIter, ID>;

  const IterIter& base() const { return _it_it; }
  // const JumpByEqualNext& policy() const { return *this; }
  difference_type value() const { return *(std::next(_it_it)) - *_it_it; }
  // JumpByEqualNext() = default;
  JumpByEqualNext(const IterIter& iter_it) : _it_it(iter_it) {}
  
  template <typename IT>
  JumpByEqualNext(const JumpByEqualNext<IT>& other)
  : _it_it(other.base()) {
    static_assert(std::is_convertible_v<IT, IterIter>);
  }

  template <int ID> 
  operator JumpByEqualNext<IterIter, ID>() const {
    return _it_it;
  }

// protected:
public:
  
  void advance_alone() {
    ++_it_it;
  }
  void radvance_alone() {
    static_assert(std::is_base_of_v<std::bidirectional_iterator_tag, iterator_category>);
    --_it_it;
  }
  void advance_alone(difference_type i) {
    static_assert(std::is_base_of_v<std::random_access_iterator_tag, iterator_category>);
    _it_it += i;
  }
  void radvance_alone(difference_type i) {
    static_assert(std::is_base_of_v<std::random_access_iterator_tag, iterator_category>);
    _it_it -= i;
  }
 
  template <typename IT>
  void advance(IT& it) {
		// static_assert(is_iterator_v<IT>);
    static_assert(std::is_convertible_v<VT<IterIter>, IT>);

    ++_it_it;
    it = *_it_it;
    // it.base() = IterIter(*_it_it);
  }

  template <typename IT>
  void radvance(IT& it) {
		// static_assert(is_iterator_v<IT>);
    static_assert(std::is_base_of_v<std::bidirectional_iterator_tag, iterator_category>);
    static_assert(std::is_convertible_v<VT<IterIter>, IT>);
    static_assert(std::is_base_of_v<std::bidirectional_iterator_tag, IC<IterIter>>);

    --_it_it;
    it = *_it_it;
    // it.base() = IterIter(*_it_it);
  }

  template <typename IT>
  void advance(IT& it, difference_type i) {
    static_assert(std::is_base_of_v<std::random_access_iterator_tag, iterator_category>);
    static_assert(std::is_convertible_v<VT<IterIter>, IT>);
    static_assert(std::is_base_of_v<std::random_access_iterator_tag, IC<IterIter>>);
    _it_it += i;
    it = *_it_it;
    // it.base() = IterIter(*_it_it);
  }

  template <typename IT>
  void radvance(IT& it, difference_type i) {
    static_assert(std::is_base_of_v<std::random_access_iterator_tag, iterator_category>);
    static_assert(std::is_convertible_v<VT<IterIter>, IT>);
    static_assert(std::is_base_of_v<std::random_access_iterator_tag, IC<IterIter>>);
    _it_it -= i;
    it = *_it_it;
    // it.base() = IterIter(*_it_it);
  }

  template <typename JIT>
  static difference_type get_diff(const JIT& lhs, const JIT& rhs) {
    // static_assert(std::is_base_of_v<std::random_access_iterator_tag, IC<IterIter>>);
    static_assert(std::is_base_of_v<std::random_access_iterator_tag, iterator_category>);
    // return lhs.policy()._it_it - rhs.policy()._it_it;
    return lhs.policy().base() - rhs.policy().base();
  }

  // Examples:
  //   std::list l = {'a', 'b', 'c', 'd', 'e', 'f'};
  //   std::vector/list iters = {l.begin(), std::next(l.begin(), 2), std::next(l.begin(), 4), l.end()};
  //   auto itb = make_tensor_iterable(
  //     l.begin(),
  //     iters.begin(),
  //     iters.size() - 1
  //   );
  //   auto itb = make_tensor_iterable_ext(
  //     l.begin(), NoPolicy(),
  //     iters.begin(), UseItbSize(),
  //     std::prev(iters.end(), 2)
  //   );

};


// ----------------------------------------------------------- //


// NOTE: Policy traits concept
/*template <typename Policy, template <typename...> class User>
struct policy_traits {};


template <>
struct policy_traits<NoPolicy, jump_iterator> {
  
  using difference_type = std::ptrdiff_t;
  using iterator_category = std::random_access_iterator_tag;
  using policy_category = fixed_jump_policy_tag;

};

template <int N>
struct policy_traits<StaticJumpPolicy<N>, jump_iterator> {
  
  using difference_type = int;
  using iterator_category = std::random_access_iterator_tag;
  using policy_category = fixed_jump_policy_tag;

};

template <>
struct policy_traits<FixedJumpPolicy, jump_iterator> {
  
  using difference_type = std::ptrdiff_t;
  using iterator_category = std::random_access_iterator_tag;
  using policy_category = fixed_jump_policy_tag;

};

template <typename PolIter>
struct policy_traits<JumpByIndexDiff<PolIter>, jump_iterator> {
  
  using difference_type = PolIter;
  using iterator_category = std::random_access_iterator_tag;
  using policy_category = nonfixed_jump_policy_tag;

};

template <typename PolIter>
struct policy_traits<JumpByIndexValue<PolIter>, jump_iterator> {
  
  using difference_type = PolIter;
  using iterator_category = std::bidirectional_iterator_tag;
  using policy_category = nonfixed_jump_policy_tag;

};*/


// =================================================================== //

// TODO: Fix
// std::vector vec = {1, 2, 3};
// // jump_iterator jit(vec.cbegin());
// // jit = vec.begin();
// jump_iterator jit(vec.begin());
// decltype(vec.cbegin()) it = jit;


template <typename IterType, typename Policy>
class jump_iterator;


template <typename T>
struct is_jump_iterator
: public std::false_type {};

template <typename IT, typename P>
struct is_jump_iterator<jump_iterator<IT, P>>
: public std::true_type {};

template <typename T>
constexpr bool is_jump_iterator_v = is_jump_iterator<T>::value;



template <typename IterType, typename Policy>
// template <typename IterType, typename Policy = NoPolicy<>>
// template <typename IterType, typename Policy, bool STACKABLE = false>
class jump_iterator : private Policy {
// class jump_iterator : private Policy::type {

  using ThisType = jump_iterator<IterType, Policy>;

  friend Policy; // NOTE: !!! (Because of get_diff(...))
  
public:
  
  // Helper type aliases for tensor_iterable
  using base_type = IterType;
  using abs_base_type = IterType;

  static constexpr int policy_id = 0;
  using policy_type = Policy;
  // using policy_type = typename Policy::type;

  using difference_type = typename policy_type::difference_type;
  using iterator_category = typename policy_type::iterator_category;

  using value_type = typename std::iterator_traits<IterType>::value_type;
  using reference = typename std::iterator_traits<IterType>::reference;
  using pointer = typename std::iterator_traits<IterType>::pointer;

  // Make those methods public from the protectedly inherited Policy
  // using policy_type::policy;
  // using stride = policy_type::value;

  const policy_type& policy() const {
    return static_cast<const policy_type&>(*this);
  }
  
	policy_type& policy() {
    return static_cast<policy_type&>(*this);
  }

  difference_type stride() const {
    return policy_type::value();
  }


protected:

  IterType _it{};

public:

  base_type& base() { return _it; }
  const base_type& base() const { return _it; }
  // void set_base(const IterType& it) { _it = it; }
  
  // Example:
  // std::vector<int> vec;
  // jump_iterator jit(vec.cbegin());
  // jit = vec.begin();
  // jit = vec.data();

  // template <typename ...Args>
  // jump_iterator(const IterType& iter, Args&&... args)
  //   : _it(iter), policy_type(std::forward<Args>(args)...) {}
  
  template <typename IT, typename P, typename = std::enable_if_t<
   std::is_constructible_v<IterType, IT> && std::is_constructible_v<policy_type, P>>>
  jump_iterator(const IT& iter, const P& pol)
    : _it(iter), policy_type(pol) {}

  template <typename P = Policy, typename = std::enable_if_t<
    std::is_default_constructible_v<P>>>
  jump_iterator(const IterType& iter) : _it(iter), policy_type() {}


  // Why this constructor doesnt call with an implicit
  //  conversion from a single argument of the policy constructor ?
  // Because you may be giving iterator when the argument is 
  //  const iterator, so it gets a very long ching of conversions
  //  iterator -> const_iterator -> Policy<const_iterator>
  //  that can not be implicitly deduced
  // And thats why we would just have the helper constructor
  //  above this
  //jump_iterator(const IterType& iter, const policy_type& pol)
  //  : _it(iter), policy_type(pol) {}

  template <typename IT, typename P, typename = std::enable_if_t<
    std::is_convertible_v<IT, IterType> && std::is_convertible_v<P, policy_type>>>
  jump_iterator(const jump_iterator<IT, P>& other)
    : _it(other.base()), policy_type(other.policy()) {}

  template <typename P = Policy, typename =
    std::enable_if_t<std::is_base_of_v<NoPolicy<>, P>>>
  operator const IterType& () const { return _it; }
  
  template <typename P = Policy, typename =
    std::enable_if_t<std::is_base_of_v<NoPolicy<>, P>>>
  operator IterType& () { return _it; }


  reference operator*() const { return *_it; }
  pointer operator->() const { return _it.operator->(); }

  template <typename IC = iterator_category, typename = std::enable_if_t<std::is_base_of_v<std::random_access_iterator_tag, IC>>>
  reference operator[](difference_type i) const {
    auto temp(_it); 
    policy_type::advance(temp, i); 
    return *temp;
  }


  ThisType& operator++() { policy_type::advance(_it) ; return *this; }
  ThisType operator++(int) { auto temp(*this); ++(*this); return temp; }

  template <typename IC = iterator_category, typename = std::enable_if_t<std::is_base_of_v<std::bidirectional_iterator_tag, IC>>>
  ThisType& operator--() { policy_type::radvance(_it); return *this; }
  template <typename IC = iterator_category, typename = std::enable_if_t<std::is_base_of_v<std::bidirectional_iterator_tag, IC>>>
  ThisType operator--(int) { auto temp(*this); --(*this); return temp; }


  template <typename IC = iterator_category, typename = std::enable_if_t<std::is_base_of_v<std::random_access_iterator_tag, IC>>>
  ThisType& operator+=(difference_type i) { policy_type::advance(_it, i); return *this; }
  // friend ThisType operator+(ThisType iter, difference_type i) { return iter += i; }
  template <typename IC = iterator_category, typename = std::enable_if_t<std::is_base_of_v<std::random_access_iterator_tag, IC>>>
  ThisType operator+(difference_type i) const { auto temp(*this); return temp += i; }
  template <typename IC = iterator_category, typename = std::enable_if_t<std::is_base_of_v<std::random_access_iterator_tag, IC>>>
  friend ThisType operator+(difference_type i, ThisType iter) { return iter += i; }
 
  template <typename IC = iterator_category, typename = std::enable_if_t<std::is_base_of_v<std::random_access_iterator_tag, IC>>>
  ThisType& operator-=(difference_type i) { policy_type::radvance(_it, i); return *this; }
  template <typename IC = iterator_category, typename = std::enable_if_t<std::is_base_of_v<std::random_access_iterator_tag, IC>>>
  friend ThisType operator-(ThisType iter, difference_type i) { return iter -= i; }
  template <typename IC = iterator_category, typename = std::enable_if_t<std::is_base_of_v<std::random_access_iterator_tag, IC>>>
  difference_type operator-(const ThisType& rhs) const {
    // return policy_type::get_diff(this->_it, rhs._it);
    return policy_type::get_diff(*this, rhs);
  }


  bool operator==(const jump_iterator& other) const {
    if constexpr (std::is_base_of_v<std::random_access_iterator_tag, iterator_category>)
      return !(*this - other);
    else
      return _it == other._it;
  }

  bool operator!=(const jump_iterator& other) const {
    if constexpr (std::is_base_of_v<std::random_access_iterator_tag, iterator_category>)
      return *this - other;
    else
      return _it != other._it;
  }

  template <typename IC = iterator_category, typename = std::enable_if_t<std::is_base_of_v<std::random_access_iterator_tag, IC>>>
  bool operator<(const jump_iterator& other) const {
    // return _it < other._it;
    return (*this - other) < 0;
  }
  
  template <typename IC = iterator_category, typename = std::enable_if_t<std::is_base_of_v<std::random_access_iterator_tag, IC>>>
  bool operator<=(const jump_iterator& other) const {
    // return _it <= other._it;
    return (*this - other) <= 0;
  }
  
  template <typename IC = iterator_category, typename = std::enable_if_t<std::is_base_of_v<std::random_access_iterator_tag, IC>>>
  bool operator>(const jump_iterator& other) const {
    // return _it > other._it;
    return (*this - other) > 0;
  }
  
  template <typename IC = iterator_category, typename = std::enable_if_t<std::is_base_of_v<std::random_access_iterator_tag, IC>>>
  bool operator>=(const jump_iterator& other) const {
    // return _it >= other._it;
    return (*this - other) >= 0;
  }


};

template <
  typename PolicyArg, 
  bool IS_ITER = is_iterator_v<std::remove_cvref_t<PolicyArg>>
>
class arg_to_jump_policy;

template <typename PolicyArg>
class arg_to_jump_policy<PolicyArg, false> {
  using PA = std::remove_cvref_t<PolicyArg>;
public:
  using type = _if_t<
    std::is_integral_v<PA>,
    FixedJumpPolicy<PA>,
    PA
  >;
};

template <typename PolicyArg>
class arg_to_jump_policy<PolicyArg, true> {
  using PA = std::remove_cvref_t<PolicyArg>;
public:
  using type = _if_t<
    std::is_integral_v<typename std::iterator_traits<PA>::value_type>,
    JumpByIndexDiff<PA>,
    _if_t<
      is_iterator_v<typename std::iterator_traits<PA>::value_type>,
      JumpByEqualNext<PA>,
      // void
      PA
    >
  >;
};

template <typename PolicyArg>
using arg_to_jump_policy_t = typename arg_to_jump_policy<PolicyArg>::type;



// NOTE:
// Because of the perfect forwarding
//  in make_tensor_iterator/iterable functions
//  we need to ensure that the policy arguments
//  are not const or reference
/*template <typename PolicyArg>
using arg_to_jump_policy_t = 
  _if_t<
    std::is_integral_v<std::remove_cvref_t<PolicyArg>>,
    FixedJumpPolicy<std::remove_cvref_t<PolicyArg>>,
    _if_t<
      is_iterator_v<std::remove_cvref_t<PolicyArg>>,
      JumpByIndexDiff<std::remove_cvref_t<PolicyArg>>,
      std::remove_cvref_t<PolicyArg>
    >
  >;*/

/*template <typename PolicyArg>
using arg_to_jump_policy_t = 
  _if_t<
    std::is_integral_v<PolicyArg>,
    FixedJumpPolicy<PolicyArg>,
    _if_t<
      is_iterator_v<PolicyArg>,
      JumpByIndexDiff<PolicyArg>,
      PolicyArg
    >
  >;*/


// Template Deduction Guide
template <typename IT, typename PolicyArg>
jump_iterator(const IT&, const PolicyArg&)
  -> jump_iterator<
    IT,
    arg_to_jump_policy_t<PolicyArg>
  >;

// template <typename IT>
// jump_iterator(const IT&)
//   -> jump_iterator<
//     IT,
//     NoPolicy<>
//   >;


