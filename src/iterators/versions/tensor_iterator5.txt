#pragma once

// NOTE: Based on tensor_iterator1

#include "iterable.hpp"
#include "jump_iterator.hpp"
#include "crtp_iterator.hpp"

#include <iterator>
#include <type_traits>
// #include <memory>
#include <ostream>

// NOTE: This approach uses C++20 [[no_unique_adress]] attribute

// NOTE: num of flat args = policy_id + 1

// TODO:
// Make the initial policy_id in jump_iterator to be 1 instead of 0
// this way, the number of all policies will be equal to the policy_id
// and then the 0 policy_id will represent the absolute base type

// TODO:
// Make the constructors arguments to filter out
// default initializable policies
// For example the type
// using itb_type = TensorIterable<iter, NoPolicy, FixedJumpPolicy, UseItbSize, FixedJumpPolicy>
// currenly should only be constructed like this:
// itb_type itb(iter, NoPolicy(), 4, UseItbSize(), 20)
// instead, make it to be able to be constructed like this
// itb_type itb(iter, 4, 20);

// TODO: transpose function for rank 2 (matrix) TensorIterable types

// TODO:
// 1) Make the non Ext versions to be STACKABLE
// 2) Make the helper functions and aliases to stack
// tensor iterators, instead of making jump_iterator<tensor_iterator, NoPolicy>
// 3) Make the helper make function to also be passed boolean
//  tags as arguments, for the STACKABLE or NONSTACKABLE flags
// 4) Make the constructor of tensor iterator to be able to
//   get an iterator as argument for a policy that stores
//   the same type iterator, but is const
// 4) Get rid of policy_id and base_type in jump_iterator
//  and istead, just do _if checked recursive calculation
//  of them in BaseTensorIterableLayer,
//  also make it such that policy_id is even in BaseTensorIterableLayer
//  and that policy_id/2 exactly equals the rank of the tensor iterable

// NOTE: Should you move the STACKABLE flags into the policies ?



// NOTE: JUST DONT USE THE STACKABLE FEATURE
// Only downgrade is that you would not be able
// to iterate a row major matrix by columns


template <typename BaseIter, bool STACKABLE>
struct __base_type_impl;

template <typename BaseIter>
struct __base_type_impl<BaseIter, true> {
  using type = BaseIter;
};

template <typename BaseIter>
struct __base_type_impl<BaseIter, false> {
  using type = typename BaseIter::base_type;
};

// struct GetBaseFunctor {
//   template <typename T>
//   auto&& operator()(T&& val) const {
//     return val.base();
//   }
// };

template <typename, typename, bool> 
class BaseTensorIterable;

template <typename IterType, typename SizePolicy, bool STACKABLE = true>
using InputTensorIterable = InputIterableLayer<BaseTensorIterable<IterType, SizePolicy, STACKABLE>>;

// Iterable with assignment of same size containers
template <typename IterType, typename SizePolicy, bool STACKABLE = true>
using TensorIterable = OutputIterableLayer<InputIterableLayer<BaseTensorIterable<IterType, SizePolicy, STACKABLE>>>;


/*template <bool STCKB>
struct __get_itb_base_iter {

	template <typename IT, typename POL, bool ST>
  const auto& operator()(const BaseTensorIterable<IT, POL, ST>& itb) const {
		if constexpr (STCKB)
			// return itb.as_iter();
			return itb.as_iter().base();
		else
			return itb.as_iter().base().base();
			// return itb.base();
			// return val.as_iter().base(); // !! THIS WORKS !!
			// twice base() call, so we surpass the STCKB of the Iterable, depending only on the TensorIterator's TCKB
			// return val.as_iter().base().base(); 
  }
	
	template <typename IT, typename POL, bool ST>
  auto& operator()(BaseTensorIterable<IT, POL, ST>& itb) const {
		if constexpr (STCKB)
			// return itb.as_iter();
			return itb.as_iter().base();
		else
			return itb.as_iter().base().base();
			// return itb.base();
			// return val.as_iter().base(); // !! THIS WORKS !!
			// twice base() call, so we surpass the STCKB of the Iterable, depending only on the TensorIterator's TCKB
			// return val.as_iter().base().base();
  }

};*/

struct GetItbBaseFunctor {

	template <typename IT, typename POL, bool ST>
  const auto& operator()(const BaseTensorIterable<IT, POL, ST>& itb) const {
		return itb.as_iter().base();
	}
	
	template <typename IT, typename POL, bool ST>
  auto& operator()(BaseTensorIterable<IT, POL, ST>& itb) const {
		return itb.as_iter().base();
  }

};


struct GetAsIterFunctor {
	
	template <typename IterType, typename Policy, bool ST>
	const typename BaseTensorIterable<IterType, Policy, ST>::as_iter_type&
	operator()(const BaseTensorIterable<IterType, Policy, ST>& itb) const {
		return itb.as_iter();
	}
	
	template <typename IterType, typename Policy, bool ST>
	typename BaseTensorIterable<IterType, Policy, ST>::as_iter_type&
	operator()(BaseTensorIterable<IterType, Policy, ST>& itb) const {
		return itb.as_iter();
	}

};


// template <typename BaseItb>
// class IterableToIterator
// : public CrtpIterator<IterableToIterator<BaseItb>, BaseItb, GetBaseFunctor> {
/*template <typename BaseItb, bool STCKB = true>
class IterableToIterator
// : public CrtpIterator<IterableToIterator<BaseItb, STCKB>, BaseItb, GetBaseFunctor> {
: public CrtpIterator<IterableToIterator<BaseItb, STCKB>, BaseItb, __get_itb_base_iter<STCKB>> {

  using ThisType = IterableToIterator<BaseItb, STCKB>;
  // using CrtpType = CrtpIterator<ThisType, BaseItb, GetBaseFunctor>;
  using CrtpType = CrtpIterator<ThisType, BaseItb, __get_itb_base_iter<STCKB>>;
	using IterType = typename CrtpType::template IterType<0>;

  template <typename, bool>
  friend class IterableToIterator;

public:

  using difference_type = typename CrtpType::difference_type;
  using iterator_category = typename CrtpType::iterator_category;
  using value_type = BaseItb;
  using reference = const value_type&;
  using pointer = const value_type*;

	// using base_type = __base_type_impl<typename CrtpType::BaseIter, STCKB>;

	// const auto& base() const {
	// 	if constexpr (STCKB)
	// 		return CrtpType::base().as_iter();
	// 	else
	// 		// return CrtpType::base().base();
	// 		return CrtpType::base().as_iter().base();
	// }
	// 
	// auto& base() {
	// 	if constexpr (STCKB)
	// 		return CrtpType::base().as_iter();
	// 	else
	// 		// return CrtpType::base().base();
	// 		return CrtpType::base().as_iter().base();
	// }

	const IterType& base() const { return CrtpType::iter(); }
	IterType& base() { return CrtpType::iter(); }


  // template <typename ...Args>
  // IterableToIterator(Args&&... args)
  // : _itb(std::forward<Args>(args)...) {}

  using CrtpType::CrtpType;

  template <typename ITB>
  IterableToIterator(const IterableToIterator<ITB>& other)
  : CrtpType(other.base()) {}

  ThisType& operator=(const ThisType& other) {
    // BaseType::base().base() = other.base().base();
    // CrtpType::base().reconstruct(other.iter());
    // CrtpType::base().reconstruct(other.base());
    CrtpType::base().reconstruct(static_cast<const CrtpType&>(other).base());
    return *this;
  }

  reference operator*() const { return CrtpType::base(); }
  pointer operator->() const { return &CrtpType::base(); }
  
  template <typename IC = iterator_category, typename = std::enable_if_t<
    std::is_base_of_v<std::random_access_iterator_tag, IC>>>
  reference operator[](difference_type i) const { auto temp(*this); ++temp; return *temp; }
	
};*/


template <typename BaseItb, typename = void>
// template <typename BaseItb, bool STCKB>
class IterableToIterator;


template <typename BaseItb>
class IterableToIterator<
	BaseItb,
	std::enable_if_t<is_jump_iterator_v<typename BaseItb::iterator>>
> : public CrtpIterator<
		IterableToIterator<BaseItb>,
		BaseItb,
		GetItbBaseFunctor
	> {

	using ThisType = IterableToIterator<BaseItb>;
	using CrtpType = CrtpIterator<
		ThisType,
		BaseItb,
		GetItbBaseFunctor
	>;

	// This is the iterator we simulate
	using IterType = typename CrtpType::template IterType<0>;
	
	// using CrtpType = _if_t<
	// 	std::is_base_of_v<
	// 		nonfixed_jump_policy_tag,
	// 		typename ItbType::policy_type::policy_category
	// 	>,
	// 	CrtpIterator<
	// 		IterableToIterator<ItbType, STCKB>,
	// 		ItbType,
	// 		GetBaseFunctor<does_have_base_v<ItbType> ? STCKB : true>,
	// 		GetPolicyIterFunctor // NOTE: Give the policy iterator to the crtp, so it increments it too
	// 	>,
	// 	CrtpIterator<
	// 		IterableToIterator<ItbType, STCKB>,
	// 		ItbType,
	// 		GetBaseFunctor<does_have_base_v<ItbType> ? STCKB : true>
	// 	>
	// >;

	static_assert(!is_iterator_v<BaseItb>);
	static_assert(is_container_v<BaseItb>);

	static constexpr bool STACKABLE = IterType::STACKABLE;
	// static constexpr bool IS_JUMP_ITER = is_jump_iterator_v<IterType>;

public:

	using typename CrtpType::iterator_category;
	using typename CrtpType::difference_type;
	using CrtpType::CrtpType;

	using value_type = BaseItb;
	// using value_type = typename BaseItb::base_type;
	using reference = const value_type&;
	using pointer = const value_type*;

	reference operator*() const {
		return CrtpType::base();
	}
	
	pointer operator->() const {
		return &CrtpType::base();
	}

	template <bool COND = std::is_base_of_v<std::random_access_iterator_tag,
		iterator_category>, typename = std::enable_if_t<COND>>
	reference operator[](difference_type i) const {
		ThisType temp(*this);
		return *(temp += i);
	}

	/*
	// using base_type = typename BaseItb::iterator;
	using base_type = CrtpType::template IterType<0>;
	base_type& base() { return CrtpType::iter(); }
	const base_type& base() const { return CrtpType::iter(); }
	
	static constexpr bool STACKABLE = BaseItb::iterator::STACKABLE;
	using depth_base_type = __get_depth_base_t<typename BaseItb::iterator, STACKABLE>;
	depth_base_type& depth_base() { return CrtpType::iter()}
	*/

	// template <bool COND = IS_JUMP_ITER, typename = std::enable_if_t<COND>>
	

};


// template <typename BaseItb>
// class IterableToIterator<
// 	BaseItb,
// 	std::enable_if_t<is_jump_iterator_v<typename BaseItb::iterator>>
// >;


class UseItbSize {};


template<typename IterableType, typename StridePolicy = UseItbSize, bool STACKABLE = true>
using TensorIterator = jump_iterator<IterableToIterator<IterableType>, StridePolicy, STACKABLE>;


template <typename T>
jump_iterator(const T&)
  -> jump_iterator<
    _if_t<is_iterator_v<T>, T, IterableToIterator<T>>,
    _if_t<is_iterator_v<T>, NoPolicy, UseItbSize>
  >;


template<typename IterableType, bool STACKABLE>
class jump_iterator<IterableToIterator<IterableType>, UseItbSize, STACKABLE>
: public CrtpIterator<
		jump_iterator<IterableToIterator<IterableType>, UseItbSize, STACKABLE>,
		IterableType,
		GetAsIterFunctor
	> {

  using BaseIter = IterableToIterator<IterableType>;
	using ThisType = jump_iterator<BaseIter, UseItbSize, STACKABLE>;
	using CrtpType = CrtpIterator<
		ThisType,
		IterableType,
		GetAsIterFunctor
	>;

public:

	using typename CrtpType::iterator_category;
	using typename CrtpType::difference_type;
	using CrtpType::CrtpType;

	using value_type = IterableType;
	// using value_type = typename IterableType::base_type;
	using reference = const value_type&;
	using pointer = const value_type*;

	reference operator*() const {
		return CrtpType::base();
	}
	
	pointer operator->() const {
		return &CrtpType::base();
	}

	template <bool COND = std::is_base_of_v<std::random_access_iterator_tag,
		iterator_category>, typename = std::enable_if_t<COND>>
	reference operator[](difference_type i) const {
		ThisType temp(*this);
		return *(temp += i);
	}

	using base_type = typename CrtpType::template IterType<0>::base_type;
	base_type& base() { return CrtpType::iter().base(); }
	const base_type& base() const { return CrtpType::iter().base(); }

protected:

	template <typename, typename, bool>
	friend class jump_iterator;

	using depth_base_type = typename CrtpType::template IterType<0>::base_type;
	depth_base_type& depth_base() { return CrtpType::iter().depth_base(); }
	const depth_base_type& depth_base() const { return CrtpType::iter().depth_base(); }

};



/*template <typename T>
struct is_iterable_to_iterator
: public std::false_type {};

template <typename ItbType>
struct is_iterable_to_iterator<IterableToIterator<ItbType>>
: public std::true_type {};

template <typename T>
constexpr bool is_iterable_to_iterator_v = is_iterable_to_iterator<T>::value;*/


template <typename BaseIter, typename SizePolicy, bool STCKB = true>
class BaseTensorIterable {

	static_assert(is_iterator_v<BaseIter>);
	// static_assert(!is_iterable_to_iterator_v<BaseIter>);
	// static_assert(does_have_base_v<IterType>);
  
  static constexpr bool STACKABLE = does_have_base_v<BaseIter> ? STCKB : true;
	using IterType = jump_iterator<BaseIter, SizePolicy, STCKB>;
  // using BaseIter = typename IterType::base_type;
  
  template <typename, typename, bool>
  friend class BaseTensorIterable;

  IterType _it;

protected:

	using as_iter_type = IterType;
	const as_iter_type& as_iter() const { return _it; }
	as_iter_type& as_iter() { return _it; }

	template <typename, typename>
	friend class IterableToIterator;

	// template <bool>
	// friend class __get_itb_base_iter;
	friend GetAsIterFunctor;
	friend GetItbBaseFunctor;

public:
  
	using difference_type = long long;

  // using base_type = typename __base_type_impl<BaseIter, STACKABLE>::type;
	// using base_type = _if_t<STACKABLE, BaseIter, typename BaseIter::base_type>;
	// using iterator = base_type;
	using iterator = BaseIter;

  // base_type& base() {
  //   if constexpr (STACKABLE)
  //     return _it.base();
  //   else
  //     return _it.base().base();
  // }
  //
  // const base_type& base() const {
  //   if constexpr (STACKABLE)
  //     return _it.base();
  //   else
  //     return _it.base().base();
  // }
  
  template <typename ...Args, typename = std::enable_if_t<
    std::is_constructible_v<IterType, Args...>>>
  explicit BaseTensorIterable(Args&&... args)
  : _it(std::forward<Args>(args)...) {}

  template <typename IT>
  BaseTensorIterable(const BaseTensorIterable<IT, SizePolicy, STCKB>& other)
  : _it(other._it) {}


  // template <typename IT>
  // BaseTensorIterable(const BaseTensorIterable<IT>& other)
  //   : BaseTensorIterable(other.begin(), other.end()) {}


  /*const iterator& begin() const {
		return _it.base();
	}
	
	iterator end() const {
		IterType temp(_it);
		++temp;
		return temp.base();
	}*/

	const iterator& begin() const {
		return _it.base();
	}
	
	iterator end() const {
		IterType temp(_it);
		return (++temp).base();
	}


  difference_type size() const { return std::distance(begin(), end()); }
  bool empty() const { return begin() == end(); }

  template <typename ...Args>
  void reconstruct(Args&&... args) {
    _it = iterator(std::forward<Args>(args)...);
  }
  
  // template <typename IT>
  // void reconstruct(const BaseIterable<IT>& other) {
  //   _begin_it = other.begin();
  //   _end_it = other.end();
  // }

};


/*template <typename BaseItb, bool STCKB>
class BaseTensorIterable<IterableToIterator<BaseItb>, STCKB>
: public BaseTensorIterable<jump_iterator<IterableToIterator<BaseItb>, NoPolicy<>>, STCKB> {

	using BaseType = BaseTensorIterable<jump_iterator<IterableToIterator<BaseItb>, NoPolicy<>>, STCKB>;

public:

	using BaseType::BaseType;

};*/


/*template <typename IterType, bool USE_ITB_SIZE = false, bool STACKABLE = true>
class TensorIterator
: public CrtpIterator<TensorIterator<IterType, USE_ITB_SIZE, STACKABLE>, IterType> {

  using ThisType = TensorIterator<IterType, USE_ITB_SIZE, STACKABLE>;
  using BaseType = CrtpIterator<ThisType, IterType>;
  using BaseIter = typename IterType::base_type;

protected:

  // auto& base() {
  //   if constexpr (STACKABLE)
  //     // return this->_it;
  //     return BaseType::base();
  //   else
  //     // return this->_it.base();
  //     return BaseType::base().base();
  // }
  //
  // const auto& base() const {
  //   if constexpr (STACKABLE)
  //     // return this->_it;
  //     return BaseType::base();
  //   else
  //     // return this->_it.base();
  //     return BaseType::base().base();
  // }

  // using BaseType::_it;

public:

  using difference_type = typename BaseType::difference_type;
  using iterator_category = typename BaseType::iterator_category;
  using value_type = TensorIterable<BaseIter>;
  using reference = value_type;
  using pointer = std::unique_ptr<value_type>;

  using BaseType::BaseType;

  reference operator*() const {
    return value_type(this->_it.base());
  }
  
  pointer operator->() const {
    return std::make_unique<value_type>(this->_it.base());
  }

  template <typename IC = iterator_category, std::enable_if_t<
    std::is_base_of_v<std::random_access_iterator_tag, IC>>>
  reference operator[](difference_type i) const {
    auto temp(this->_it); temp += i; return value_type(temp.base());
  }

  
//   template <typename ...Args, typename = std::enable_if_t<
//     std::is_constructible_v<IterType, Args...>>>
//   TensorIteratorLayer(Args&&... args)
//   : _it(std::forward<Args>(args)...) {}
//
// protected:
//
//   _itb

};*/


template <typename BaseIterType, typename SizePolicy, bool STACKABLE>
inline std::ostream& operator<<(std::ostream& stream, const BaseTensorIterable<BaseIterType, SizePolicy, STACKABLE>& iterable) {
  stream << "{";
  for(auto iter = iterable.begin(); iter != iterable.end();) {
    stream << *iter;
    if (++iter != iterable.end())
      stream << ", ";
  }
  stream << "}";

  return stream;
}


// template <typename IterType, bool STCKB_OLD, bool STCKB_NEW>
// struct change_stackable<TensorIterable<IterType, STCKB_OLD>, STCKB_NEW> {
// 	using type = TensorIterable<IterType, STCKB_NEW>;
// };


/*// TensorIteratorLayer<index_iterator<int>> it(15);
  // it += 69;
  // std::cout << *it << "\n";

  using itb_type1 = TensorIterable<jump_iterator<index_iterator<int>, FixedJumpPolicy<int>>>;
  itb_type1 itb1 = jump_iterator(index_iterator(0), 5);

  jump_iterator jit(index_iterator(1), JumpByEqualStatic<3>());
  std::cout << *jit << "\n";
  std::cout << *++jit << "\n";

  // for(auto val : itb1)
  //   std::cout << val << "\n";

  using itb_iter1 = IterableToIterator<itb_type1>;
  itb_iter1 it1 = itb1;

  // for(int i = 0; i < 3; ++i)
  //   std::cout << *(it1++) << "\n";
*/

/*using base_itb_iter = jump_iterator<jump_iterator<index_iterator<int>, FixedJumpPolicy<int>>, FixedJumpPolicy<int>>;
  using itb_iter1 = TensorIterator<base_itb_iter>;
  itb_iter1 it1 = jump_iterator(jump_iterator(index_iterator(0), 3), 1);

  // for(int i = 0; i < 3; ++i)
  //   std::cout << *(it1++) << "\n";

  using itb_type2 = TensorIterable<jump_iterator<itb_iter1, FixedJumpPolicy<int>>>;
  itb_type2 itb2 = jump_iterator(it1, 5);

  // using itb_iter2 = TensorIterator<jump_iterator<>>;
  // itb_iter2 it2 = jump_iterator(it1, 5);

  
  for (auto val : itb2)
    std::cout << val << "\n";*/

  // std::cout << sizeof(jump_iterator<index_iterator<int>, NoPolicy<>>) << "\n";
  // std::cout << sizeof(jump_iterator<jump_iterator<jump_iterator<index_iterator<int>, NoPolicy<>>, NoPolicy<>>, NoPolicy<>>) << "\n";
  // std::cout << sizeof(jump_iterator<jump_iterator<jump_iterator<index_iterator<int>, NoPolicy<0>>, NoPolicy<1>>, NoPolicy<2>>) << "\n";



