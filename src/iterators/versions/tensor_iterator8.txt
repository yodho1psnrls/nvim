#pragma once

// NOTE: Based on tensor_iterator1

// #include "iterable.hpp"
#include "view.hpp"
#include "jump_iterator.hpp"
#include "crtp_iterator.hpp"

#include <iterator>
#include <type_traits>
// #include <memory>
// #include <ostream>


template <typename, typename, bool> 
class BaseTensorView;

template <typename IterType, typename SizePolicy, bool STACKABLE = true>
using InputTensorView = InputViewLayer<BaseTensorView<IterType, SizePolicy, STACKABLE>>;

// Iterable with assignment of same size containers
template <typename IterType, typename SizePolicy, bool STACKABLE = true>
using TensorView = OutputViewLayer<InputViewLayer<BaseTensorView<IterType, SizePolicy, STACKABLE>>>;


/*template <bool SKIP_SIZE>
struct GetAsIterFunctor {
	
	template <typename IterType, typename Policy, bool ST>
	const get_base_type_t<typename BaseTensorIterable<IterType, Policy, ST>::as_iter_type, SKIP_SIZE>&
	operator()(const BaseTensorIterable<IterType, Policy, ST>& itb) const {
		if constexpr (SKIP_SIZE)
			return itb.as_iter().base();
		else
			return itb.as_iter();
	}
	
	template <typename IterType, typename Policy, bool ST>
	get_base_type_t<typename BaseTensorIterable<IterType, Policy, ST>::as_iter_type, SKIP_SIZE>&
	operator()(BaseTensorIterable<IterType, Policy, ST>& itb) const {
		if constexpr (SKIP_SIZE)
			return itb.as_iter().base();
		else
			return itb.as_iter();
	}

};*/


/*template <size_t SKIP_DEPTH = 0>
struct GetAsIterFunctor {
	
	template <typename IterType, typename Policy, bool ST>
	const get_base_typedef_t<typename BaseTensorView<IterType, Policy, ST>::as_iter_type, SKIP_DEPTH>&
	operator()(const BaseTensorView<IterType, Policy, ST>& itb) const {
		if constexpr (SKIP_DEPTH == 0)
			return itb.as_iter();
		else if constexpr (SKIP_DEPTH == 1)
			return itb.as_iter().base();
		else
			return get_depth_base<SKIP_DEPTH>(itb.as_iter());
	}
	
	template <typename IterType, typename Policy, bool ST>
	get_base_typedef_t<typename BaseTensorView<IterType, Policy, ST>::as_iter_type, SKIP_DEPTH>&
	operator()(BaseTensorView<IterType, Policy, ST>& itb) const {
		if constexpr (SKIP_DEPTH == 0)
			return itb.as_iter();
		else if constexpr (SKIP_DEPTH == 1)
			return itb.as_iter().base();
		else
			return get_depth_base<SKIP_DEPTH>(itb.as_iter());
	}

};*/


template <size_t SKIP_DEPTH = 0>
struct GetAsIterFunctor {
	
	template <typename IterType, typename Policy, bool ST>
	const auto& operator()(const BaseTensorView<IterType, Policy, ST>& itb) const {
		if constexpr (SKIP_DEPTH == 0)
			return itb.as_iter();
		else if constexpr (SKIP_DEPTH == 1)
			return itb.as_iter().base();
		else
			return get_depth_base<SKIP_DEPTH>(itb.as_iter());
	}
	
	template <typename IterType, typename Policy, bool ST>
	auto& operator()(BaseTensorView<IterType, Policy, ST>& itb) const {
		if constexpr (SKIP_DEPTH == 0)
			return itb.as_iter();
		else if constexpr (SKIP_DEPTH == 1)
			return itb.as_iter().base();
		else
			return get_depth_base<SKIP_DEPTH>(itb.as_iter());
	}

};


template <typename ViewType, size_t SKIP_DEPTH = 0>
// template <typename ViewType, bool SKIP_SIZE = false>
class ViewToIterator
: public CrtpIterator<ViewToIterator<ViewType, SKIP_DEPTH>, ViewType, GetAsIterFunctor<SKIP_DEPTH>>{
// : public CrtpIterator<IterableToIterator<ViewType, SKIP_SIZE>, ViewType, GetAsIterFunctor<SKIP_SIZE>>{

	// static_assert(!is_iterator_v<ViewType>);
	static_assert(is_view_v<ViewType>);
	// static_assert(std::is_base_of_v<BaseTensorView<typename ViewType::iterator..., ViewType>);

	using ThisType = ViewToIterator<ViewType, SKIP_DEPTH>;
	using CrtpType = CrtpIterator<ThisType, ViewType, GetAsIterFunctor<SKIP_DEPTH>>;
	// using ThisType = IterableToIterator<ViewType, SKIP_SIZE>;
	// using CrtpType = CrtpIterator<ThisType, ViewType, GetAsIterFunctor<SKIP_SIZE>>;
	using IterType = typename CrtpType::template IterType<0>;

protected:

	// template <typename, bool>
	template <typename, size_t>
	friend class IterableToIterator;

	const ViewType& itb() const { return CrtpType::base(); }

public:

	using CrtpType::CrtpType;

	template <typename ITB, typename = std::enable_if_t<std::is_constructible_v<ViewType, ITB>>>
	ViewToIterator(const ViewToIterator<ITB, SKIP_DEPTH>& other)
	// IterableToIterator(const IterableToIterator<ITB, SKIP_SIZE>& other)
	// : CrtpType(static_cast<const CrtpIterator<IterableToIterator<ITB>, ITB, GetAsIterFunctor>&>(other).base()) {}
	: CrtpType(other.itb()) {}

	using typename CrtpType::iterator_category;
	using typename CrtpType::difference_type;

	using value_type = ViewType;
	using reference = const value_type&;
	using pointer = const value_type*;

	reference operator*() const { return CrtpType::base(); }
	pointer operator->() const { return &CrtpType::base(); }
	
  template <typename IC = iterator_category, typename = std::enable_if_t<
    std::is_base_of_v<std::random_access_iterator_tag, IC>>>
  reference operator[](difference_type i) const {
		ThisType temp(*this);
		return *(temp += i);
	}

	// static constexpr size_t NUM_DEPTH = IterType::NUM_DEPTH;
	// using depth_base_type = typename IterType::depth_base_type;

	using iterator_equivalent = IterType;

	// using base_type = typename IterType::base_type;
	// base_type& base() { return CrtpType::iter().base(); }
	// const base_type& base() const { return CrtpType::iter().base(); }

	static constexpr bool DOES_HAVE_BASE = does_have_ref_base_method_v<IterType>;
	
	template <bool COND = DOES_HAVE_BASE, typename = std::enable_if_t<COND>>
	auto& base() { return CrtpType::iter().base(); }
	
	template <bool COND = DOES_HAVE_BASE, typename = std::enable_if_t<COND>>
	const auto& base() const { return CrtpType::iter().base(); }

};

template <typename ViewType>
ViewToIterator(const ViewType&)
-> ViewToIterator<ViewType>;

template <typename ViewType, size_t SKIP_DEPTH>
struct get_iter_depth<ViewToIterator<ViewType, SKIP_DEPTH>>
: public get_iter_depth<typename ViewToIterator<ViewType, SKIP_DEPTH>::iterator_equivalent> {};

// template <typename ViewType, size_t SKIP_DEPTH, long long DIFF>
// struct add_depth_to_jump_iterator<IterableToIterator<ViewType, SKIP_DEPTH>, DIFF>
// : public add_depth_to_jump_iterator<typename IterableToIterator<ViewType, SKIP_DEPTH>::jump_iter_equivalent, DIFF> {};
//
// template <typename ViewType>
// struct rec_jump_iterator<IterableToIterator<ViewType>>
// : public rec_jump_iterator<typename IterableToIterator<ViewType>::jump_iter_equivalent> {};

// template <template <typename> class ItbLayer, typename JmpIter, long long DIFF>
// struct add_depth_to_jump_iterator<IterableToIterator<ItbLayer<JmpIter>>, DIFF> {
// 	// BUG: ItbLayer specialization wouldnt work, because its typename is
// 	// another ItbLayer, only for the ViewType types, the typename is an Iterator
// 	using type = IterableToIterator<ItbLayer<typename add_depth_to_jump_iterator<JmpIter, DIFF>::type>>;
// };


struct UseViewSize {};


// template <typename ViewType, typename StridePolicy = UseItbSize, bool STCKB = true>
// using TensorIterator = _if_t<
// 	std::is_same_v<StridePolicy, UseItbSize>,
// 	IterableToIterator<ViewType>,
// 	SkipSizeTensorIterator<ViewType, StridePolicy, STCKB>
// >;


template <
	typename ViewType,
	typename StridePolicy = UseViewSize,
	bool STACKABLE = true
>
using TensorIterator = _if_t<
	std::is_same_v<StridePolicy, UseViewSize>,
	ViewToIterator<ViewType, 0>,
	_if_t<
		// STCKB && does_have_base_v<typename ViewType::iterator>,
		STACKABLE,
		jump_iterator<ViewToIterator<ViewType, 1>, StridePolicy>,
		rec_jump_iterator_t<jump_iterator<ViewToIterator<ViewType, 1>, StridePolicy>>
	>
>;



template <
	typename BaseIter,
	typename SizePolicy = FixedJumpPolicy<typename std::iterator_traits<BaseIter>::difference_type>,
	bool STACKABLE = true
>
class BaseTensorView {

	static_assert(is_iterator_v<BaseIter>);

	using IterType = _if_t<
		STACKABLE,
		jump_iterator<BaseIter, SizePolicy>,
		rec_jump_iterator_t<jump_iterator<BaseIter, SizePolicy>>
	>;

  IterType _it;

protected:

	template <size_t>
	// template <bool>
	friend class GetAsIterFunctor;

	using as_iter_type = IterType;
	const as_iter_type& as_iter() const noexcept { return _it; }
	as_iter_type& as_iter() noexcept { return _it; }

public:
  
	using iterator = typename IterType::base_type;
	using difference_type = typename std::iterator_traits<iterator>::difference_type;
 
  template <typename ...Args, typename = std::enable_if_t<
    std::is_constructible_v<IterType, Args...>>>
  explicit BaseTensorView(Args&&... args)
  : _it(std::forward<Args>(args)...) {}

  template <typename IT>
  BaseTensorView(const BaseTensorView<IT, SizePolicy, STACKABLE>& other)
  : _it(other._it) {}

	const iterator& begin() const {
		return _it.base();
	}
	
	iterator end() const {
		IterType temp(_it);
		return (++temp).base();
	}

  // difference_type size() const { return std::distance(begin(), end()); }
  // bool empty() const { return begin() == end(); }

  difference_type size() const {
		if constexpr (STACKABLE)
			return _it.stride();
		else
			return std::distance(begin(), end());
	}

  bool empty() const {
		if constexpr (STACKABLE)
			return !_it.stride();
		else
			return begin() == end();
	}

  template <typename ...Args, typename =
		std::enable_if_t<std::is_constructible_v<IterType, Args...>>>
  void reconstruct(Args&&... args) {
    _it = IterType(std::forward<Args>(args)...);
  }

};


// template <typename IterType, typename SizeArg>
// BaseTensorIterable(const IterType&, const SizeArg&)
// 	-> BaseTensorIterable<
// 		IterType,
// 		arg_to_jump_policy_t<SizeArg>
// 	>;


/*template <typename BaseIterType, typename SizePolicy, bool STACKABLE>
inline std::ostream& operator<<(std::ostream& stream, const BaseTensorView<BaseIterType, SizePolicy, STACKABLE>& iterable) {
  stream << "{";
  for(auto iter = iterable.begin(); iter != iterable.end();) {
    stream << *iter;
    if (++iter != iterable.end())
      stream << ", ";
  }
  stream << "}";

  return stream;
}*/


